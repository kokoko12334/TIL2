# stable하다는 것은 값은 값에 대해서 정렬이후에도 순서가 변하지 안는거
### 1. 버블 정렬 (Bubble Sort)
- **방법**: 인접한 두 원소를 비교하여 큰 원소를 뒤로 보내는 과정을 반복합니다. 각 패스스루마다 가장 큰 원소가 맨 뒤로 이동하므로, 반복할 때마다 정렬해야 할 원소의 수가 하나씩 줄어듭니다.
- **시간 복잡도**: 평균 및 최악의 경우 O(n^2)
- stable임

### 2. 선택 정렬 (Selection Sort)
- **방법**: 전체 원소 중에서 최소값(또는 최대값)을 찾아 선택한 후, 맨 앞의 원소와 교환합니다. 다음에는 두 번째 원소부터 같은 과정을 반복합니다.
- **시간 복잡도**: 항상 O(n^2)
- unstable : [4,4,2,1] => 0인데스의 4랑 1이랑 바뀌어서 순서가 바뀐다.

### 3. 삽입 정렬 (Insertion Sort)
- **방법**: 각 반복에서 하나의 입력 원소를 이미 정렬된 배열 부분에 적절한 위치에 삽입하여 정렬된 배열을 확장해 나갑니다.
- **시간 복잡도**: 최선의 경우 O(n), 평균 및 최악의 경우 O(n^2)
- stable임

### 4. 퀵 정렬 (Quick Sort)
- **방법**: 분할 정복 방법을 사용하여, 피벗을 기준으로 작은 원소들은 피벗의 왼쪽, 큰 원소들은 피벗의 오른쪽에 위치시킨 후, 왼쪽과 오른쪽 배열에 대해 재귀적으로 같은 과정을 반복합니다.
- **시간 복잡도**: 평균 O(n log n), 최악의 경우 O(n^2), best는 퀵셀렉트 과정: n , 분할과정:logn => nlogn
- 퀵셀렉트를 이용함 
- unstable

### 5. 병합 정렬 (Merge Sort)
- **방법**: 분할 정복 방법을 사용하여, 배열을 반으로 나누고 각 부분을 재귀적으로 정렬한 후, 두 개의 정렬된 리스트를 병합합니다.
- **시간 복잡도**: 항상 O(n log n)
- stable임

### 6. 힙 정렬 (Heap Sort)
- **방법**: 배열 요소를 힙 자료구조로 구성하고, 최대 힙(또는 최소 힙)의 특성을 이용하여 정렬을 수행합니다.
- **시간 복잡도**: O(n log n)
- unstable